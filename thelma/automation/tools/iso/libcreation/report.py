"""
Trac reporting for library creation ISOs.
"""
from thelma.automation.tools.iso.libcreation.base import LibraryLayout
from thelma.automation.tools.iso.libcreation.base import NUMBER_SECTORS
from thelma.automation.tools.iso.poolcreation.generation import \
    StockSampleCreationTicketGenerator
from thelma.automation.tools.iso.poolcreation.writer import \
    StockSampleCreationTicketWorklistUploader
from thelma.automation.tools.iso.tracreporting import IsoStockTransferReporter
from thelma.automation.tools.libcreation.execution import \
    LibraryCreationIsoExecutor
from thelma.automation.tools.writers import CsvColumnParameters
from thelma.automation.tools.writers import CsvWriter
from thelma.automation.utils.base import VOLUME_CONVERSION_FACTOR
from thelma.automation.utils.base import add_list_map_element
from thelma.automation.utils.base import get_trimmed_string
from thelma.automation.utils.racksector import RackSectorTranslator
from thelma.models.iso import IsoSectorStockRack
from thelma.models.liquidtransfer import ExecutedWorklist


__docformat__ = 'reStructuredText en'
__all__ = ['LibraryCreationStockLogFileWriter',
           'LibraryCreationStockTransferReporter',
           'LibraryCreationTicketGenerator',
           'LibraryCreationTicketWorklistUploader',
           ]


class LibraryCreationTicketGenerator(StockSampleCreationTicketGenerator):
    """
    Creates an library creation trac ticket for a new ISO.

    **Return Value:** ticket ID
    """
    NAME = 'Library Creation Ticket Creator'
    #: The value for the ticket summary (title).
    SUMMARY = 'Library Creation ISO (%s)'
    #: The description for the empty ticket.
    DESCRIPTION_TEMPLATE = "Autogenerated ticket for library creation ISO " \
                           "'''%s'''.\n\nLayout number: %i\n\n"


class LibraryCreationTicketWorklistUploader(
                                StockSampleCreationTicketWorklistUploader):
    """
    Uses the worklist files the generated by the
    :class:`LibraryCreationWorklistWriter` and sends them to the ticket
    of the library creation ISO.
    """
    NAME = 'Library Creation Ticket Worklist Uploader'
    #: File name for the zip file in the Trac.
    FILE_NAME = '%s-%i_robot_worklists.zip'

    def _make_filename(self, iso):
        return self.FILE_NAME % (iso.label, iso.layout_number)


class LibraryCreationStockTransferReporter(IsoStockTransferReporter):
    EXECUTOR_CLS = LibraryCreationIsoExecutor
    SAMPLE_TYPE = 'samples'
    BASE_COMMENT = 'A stock transfer has been executed by %s ' \
                   '(see file: attachment:%s).\n\n' \
                   'Type: %s\n\n' \
                   'Library source (preparation) plates (quadrants):\n%s.\n'

    def _set_ticket_id(self):
        """
        The ticket ID is attached to the library creation ISO.
        """
        self._ticket_number = self.executor.entity.ticket_number

    def _get_sample_type_str(self):
        """
        All library members are samples.
        """
        return self.SAMPLE_TYPE

    def _get_rack_str(self):
        """
        The plate string looks different, we have one plate per quadrant
        (instead of one plate for ISO).
        """
        rack_map = \
            dict([(issr.sector_index, issr.rack.barcode)
                  for issr in self.executor.entity.iso_sample_stock_racks])
        rack_data = ['%s (Q%s)' % (rack_map[si], si + 1)
                     for si in sorted(rack_map.keys())]
        return ', '.join(rack_data)

    def _get_log_file_writer(self):
        """
        For library creation ISOs we use a special writer, the
        :class:`LibraryCreationStockLogFileWriter`.
        """
        sample_stock_racks = dict()
        for issr in self.executor.entity.iso_sample_stock_racks:
            sample_stock_racks[issr.sector_index] = issr
        writer = LibraryCreationStockLogFileWriter(
                                self.executor.get_working_layout(),
                                self._executed_stock_worklists,
                                sample_stock_racks, parent=self)
        return writer


class LibraryCreationStockLogFileWriter(CsvWriter):
    """
    Creates a log file after each library creation stock transfer.

    The log file contains molecule design pools, molecule designs, stock
    tube barcodes and volumes and the barcode and positions in the target
    rack.

    **Return Value:** file stream (CSV format)
    """
    NAME = 'Library Creation Stock Transfer Log File Writer'
    #: The index for the library molecule design pool ID column.
    LIBRARY_POOL_INDEX = 0
    #: The header for the library molecule design pool ID column.
    LIBRARY_POOL_HEADER = 'Library Pool ID'
    #: The index for the single molecule design pool ID column.
    MOLECULE_DESIGN_INDEX = 1
    #: The header for the molecule design pool ID column.
    MOLECULE_DESIGN_HEADER = 'Molecule Design ID'
    #: The index for the tube barcode column.
    TUBE_BARCODE_INDEX = 2
    #: The header for the tube barcode column.
    TUBE_BARCODE_HEADER = 'Stock Tube Barcode'
    #: The index for the volume column.
    VOLUME_INDEX = 3
    #: The header for the volume column.
    VOLUME_HEADER = 'Volume (ul)'
    #: The index for the target rack barcode column.
    TARGET_RACK_BARCODE_INDEX = 4
    #: The header for the target rack barcode column.
    TARGET_RACK_BARCODE_HEADER = 'Target Rack Barcode'
    #: The index for the target position column.
    TARGET_POSITION_INDEX = 5
    #: The header for the target position column.
    TARGET_POSITION_HEADER = 'Target Position'

    def __init__(self, library_layout, executed_worklists,
                 sample_stock_racks, parent=None):
        """
        Constructor.

        :param library_layout: The working_layout containing the molecule
            design pool data.
        :type library_layout: :class:`LibraryLayout`
        :param dict executed_worklists: The executed worklists that have been
            generated by the executor (mapped onto transfer job indices).
        """
        CsvWriter.__init__(self, parent=parent)
        #: The executed worklists that have been generated by the executor
        #: (mapped onto transfer job indices).
        self.executed_worklists = executed_worklists
        #: The working_layout containing the molecule design pool data.
        self.library_layout = library_layout
        #: The ISO sample stock racks mapped onto sector indices.
        self.sample_stock_racks = sample_stock_racks
        #: The translators for each pool stock rack (lazy initialisation).
        self.__translators = None
        #: Stores the values for the library molecule design pool ID column.
        self.__lib_pool_values = None
        #: Stores the values for the library molecule design pool ID column.
        self.__md_values = None
        #: Stores the values for the tube barcode column.
        self.__tube_barcode_values = None
        #: Stores the values for the volume column.
        self.__volume_values = None
        #: Stores the values for the target rack barcode column.
        self.__trg_rack_barcode_values = None
        #: Stores the values for the target position column.
        self.__trg_position_values = None

    def reset(self):
        CsvWriter.reset(self)
        self.__translators = dict()
        self.__lib_pool_values = []
        self.__md_values = []
        self.__tube_barcode_values = []
        self.__volume_values = []
        self.__trg_rack_barcode_values = []
        self.__trg_position_values = []

    def _init_column_map_list(self):
        """
        Creates the :attr:`_column_map_list`
        """
        self.add_info('Start log file generation ...')

        self.__check_input()
        if not self.has_errors(): self.__init_translators()
        if not self.has_errors(): self.__store_column_values()
        if not self.has_errors(): self.__generate_column_maps()

    def __check_input(self):
        # Checks the initialisation values.
        self.add_debug('Check input values ...')
        if self._check_input_class('executed worklists map',
                                   self.executed_worklists, dict):
            for i, ew in self.executed_worklists.iteritems():
                if not self._check_input_class('worklist index', i, int):
                    break
                if not self._check_input_class('executed worklist', ew,
                                               ExecutedWorklist):
                    break
        self._check_input_class('library layout', self.library_layout,
                                LibraryLayout)
        if self._check_input_class('sample stock racks map',
                                   self.sample_stock_racks, dict):
            for sector_index, issr in self.sample_stock_racks.iteritems():
                if not self._check_input_class('sector index',
                                               sector_index, int):
                    break
                if not self._check_input_class('sample stock rack', issr,
                                               IsoSectorStockRack):
                    break

    def __init_translators(self):
        # The translators are used to determine the rack position holding
        # the pool information.
        for sector_index, issr in self.sample_stock_racks.iteritems():
            barcode = issr.rack.barcode
            translator = RackSectorTranslator(
                                NUMBER_SECTORS, 0, sector_index,
                                behaviour=RackSectorTranslator.MANY_TO_ONE)
            self.__translators[barcode] = translator

    def __store_column_values(self):
        # Store the values for the columns.
        self.add_debug('Store values ...')
        target_rack_map = dict()
        for ew in self.executed_worklists.values():
            for et in ew.executed_transfers:
                target_rack_barcode = et.target_container.location.rack.barcode
                if not target_rack_map.has_key(target_rack_barcode):
                    target_rack_map[target_rack_barcode] = []
                target_rack_map[target_rack_barcode].append(et)
        barcodes = sorted(target_rack_map.keys())
        well_containers = set()
        for target_rack_barcode in barcodes:
            non_single_md_src_pool = []
            executed_transfers = target_rack_map[target_rack_barcode]
            pool_map = self.__get_sorted_executed_transfers(executed_transfers,
                                                            target_rack_barcode)
            if self.has_errors(): break
            pools = sorted(pool_map.keys(), cmp=lambda p1, p2:
                                            cmp(p1.id, p2.id))
            for pool in pools:
                ets = pool_map[pool]
                for et in ets:
                    self.__lib_pool_values.append(get_trimmed_string(pool.id))
                    volume = et.planned_transfer.volume \
                                                    * VOLUME_CONVERSION_FACTOR
                    self.__volume_values.append(get_trimmed_string(volume))
                    self.__trg_rack_barcode_values.append(target_rack_barcode)
                    trg_label = et.planned_transfer.target_position.label
                    self.__trg_position_values.append(trg_label)
                    src_tube = et.source_container
                    self.__tube_barcode_values.append(src_tube.barcode)
                    md_id = self.__get_molecule_design_id(src_tube)
                    if md_id is None:
                        info = '%s (rack %s)' % (src_tube.barcode,
                                                 target_rack_barcode)
                        non_single_md_src_pool.append(info)
                    else:
                        self.__md_values.append(get_trimmed_string(md_id))
            if len(non_single_md_src_pool) > 0:
                msg = 'Some source container contain more than one ' \
                      'molecule design: %s.' % (sorted(non_single_md_src_pool))
                self.add_error(msg)
        if len(well_containers) > 0:
            well_container_list = list(well_containers)
            well_container_list.sort()
            msg = 'Some source containers in the worklists are wells: %s!' \
                   % (well_container_list)
            self.add_error(msg)

    def __get_sorted_executed_transfers(self, executed_transfers,
                                        target_rack_barcode):
        # Sorts the executed transfer of a worklist by molecule design pool
        # ID.
        pool_map = dict()
        no_pools = set()
        for et in executed_transfers:
            translator = self.__get_translator(target_rack_barcode)
            if translator is None: return None
            rack_pos_96 = et.target_container.location.position
            rack_pos_384 = translator.translate(rack_pos_96)

            lib_pos = self.library_layout.get_working_position(rack_pos_384)
            if lib_pos is None:
                info = '%s (rack %s)' % (rack_pos_96.label, target_rack_barcode)
                no_pools.add(info)
                continue
            pool = lib_pos.pool
            add_list_map_element(pool_map, pool, et)
        if len(no_pools) > 0:
            no_pools_list = list(no_pools)
            no_pools_list.sort()
            msg = 'Could not find molecule design pools for the following ' \
                  'target positions: %s.' % (no_pools_list)
            self.add_error(msg)
        return pool_map

    def __get_translator(self, target_rack_barcode):
        # Determines the sector index for the rack and passed the matching
        # translator (lazy initialisation).
        if self.__translators.has_key(target_rack_barcode):
            return self.__translators[target_rack_barcode]
        else:
            msg = 'Unable to determine quadrant for rack "%s".' \
                   % (target_rack_barcode)
            self.add_error(msg)
            return None

    def __get_molecule_design_id(self, tube):
        # Returns the molecule design for a single molecule design pool stock
        # tube.
        sms = tube.sample.sample_molecules
        if not len(sms) == 1: return None
        sm = sms[0]
        return sm.molecule.molecule_design.id

    def __generate_column_maps(self):
        # Initializes the CsvColumnParameters object for the
        # :attr:`_column_map_list`.
        pool_column = CsvColumnParameters(self.LIBRARY_POOL_INDEX,
                                          self.LIBRARY_POOL_HEADER,
                                          self.__lib_pool_values)
        md_column = CsvColumnParameters(self.MOLECULE_DESIGN_INDEX,
                                        self.MOLECULE_DESIGN_HEADER,
                                        self.__md_values)
        tube_column = CsvColumnParameters(self.TUBE_BARCODE_INDEX,
                                          self.TUBE_BARCODE_HEADER,
                                          self.__tube_barcode_values)
        volume_column = CsvColumnParameters(self.VOLUME_INDEX,
                                            self.VOLUME_HEADER,
                                            self.__volume_values)
        rack_barcode_column = \
            CsvColumnParameters(self.TARGET_RACK_BARCODE_INDEX,
                                self.TARGET_RACK_BARCODE_HEADER,
                                self.__trg_rack_barcode_values)
        rack_position_column = \
            CsvColumnParameters(self.TARGET_POSITION_INDEX,
                                self.TARGET_POSITION_HEADER,
                                self.__trg_position_values)
        self._column_map_list = [pool_column, md_column, tube_column,
                                 volume_column, rack_barcode_column,
                                 rack_position_column]
