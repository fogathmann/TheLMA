"""
This file is part of the TheLMA (THe Laboratory Management Application) project.
See LICENSE.txt for licensing, CONTRIBUTORS.txt for contributor information.

.. currentmodule:: thelma.entities.liquidtransfer

Handler for the :class:`GenericSampleTransferPlanParser`.
Converts the data into a :class:`WorklistSeries`

AAB
"""
from everest.entities.utils import get_root_aggregate
from thelma.tools.handlers.base import LayoutParserHandler
from thelma.tools.parsers.sampletransfer \
    import GenericSampleTransferPlanParser
from thelma.tools.semiconstants import RESERVOIR_SPECS_NAMES
from thelma.tools.semiconstants import get_item_status_future
from thelma.tools.semiconstants import get_pipetting_specs_biomek
from thelma.tools.semiconstants import get_pipetting_specs_biomek_stock
from thelma.tools.semiconstants import get_rack_specs_from_reservoir_specs
from thelma.tools.semiconstants import get_reservoir_spec
from thelma.tools.semiconstants import get_reservoir_specs_from_rack_specs
from thelma.tools.worklists.base import TRANSFER_ROLES
from thelma.tools.utils.base import MAX_PLATE_LABEL_LENGTH
from thelma.tools.utils.base import VOLUME_CONVERSION_FACTOR
from thelma.tools.utils.base import add_list_map_element
from thelma.interfaces import IRack
from thelma.interfaces import IRackShape
from thelma.entities.liquidtransfer import PlannedSampleDilution
from thelma.entities.liquidtransfer import PlannedSampleTransfer
from thelma.entities.liquidtransfer import PlannedWorklist
from thelma.entities.liquidtransfer import TRANSFER_TYPES
from thelma.entities.liquidtransfer import WorklistSeries
from thelma.entities.rack import TubeRack

__docformat__ = 'reStructuredText en'

__all__ = ['GenericSampleTransferPlanParserHandler',
           'RackOrReservoirItem']

#: TODO: think about how to add rack sample transfers and to distinguish robots

class GenericSampleTransferPlanParserHandler(LayoutParserHandler):
    """
    Converts the data from the :class:`GenericSampleTransferPlanParser`
    into a :class:`WorklistSeries`.

    **Return Value:** :class:`WorklistSeries`

    """
    NAME = 'Generic Sample Transfer Plan Parser Handler'

    _PARSER_CLS = GenericSampleTransferPlanParser

    def __init__(self, stream, allow_rack_creation=False, parent=None):
        """
        Constructor.

        :param bool allow_rack_creation: Flag indicating if it is allowed to
            create racks. This option can only be set if the racks are not
            used for worklist printing or execution right away (because the
            barcode is generated by the DB upon persisting).
        :default allow_rack_creation: *False*
        """
        LayoutParserHandler.__init__(self, stream, parent=parent)
        #: Is it allowed to create racks? This option can only be set to *True*
        #: if the racks are not used for worklist printing or execution right
        #: away (because the barcode is generated by the DB upon persisting).
        self.allow_rack_creation = allow_rack_creation
        #: The :class:`WorklistSeries` to be generated.
        self.__worklist_series = None
        #: The :class:`RackOrReservoirItem` objects mapped onto rack identifiers.
        self.__ror_map = dict()
        #: The aggregate used to fetch racks.
        self.__rack_agg = None
        #: Intermediate error storage.
        self.__missing_rack_barcodes = None
        #: Intermediate error storage.
        self.__missing_rack_barcodes = None

    def reset(self):
        LayoutParserHandler.reset(self)
        self.__worklist_series = WorklistSeries()
        self.__rack_agg = get_root_aggregate(IRack)
        self.__missing_rack_barcodes = []

    def get_racks_and_reservoir_items(self):
        """
        Returns the :class:`RackOrReservoirItem` objects found in the sheet.
        """
        return self._get_additional_value(self.__ror_map.values())

    def _initialize_parser_keys(self):
        """
        We need to set the allowed rack shapes (that is all available rack
        shapes) and the transfer role markers.
        """
        self.parser.source_role_marker = TRANSFER_ROLES.SOURCE
        self.parser.target_role_marker = TRANSFER_ROLES.TARGET
        rack_shape_agg = get_root_aggregate(IRackShape)
        rack_shape_agg.filter = None
        self.parser.allowed_rack_dimensions = [(rs.number_rows,
                                                rs.number_columns)
                                               for rs in rack_shape_agg]

    def _convert_results_to_entity(self):
        # Assembles a worklist series from the parsed sheet.
        self.add_info('Start conversion into worklist series ...')
        self._check_input_class('"allow_rack_creation" flag',
                                self.allow_rack_creation, bool)
        if not self.has_errors():
            self.__get_or_generate_racks()
        if not self.has_errors():
            self.__create_worklists()
        if not self.has_errors():
            self.add_info('Conversion completed.')
            self.return_value = self.__worklist_series

    def __get_or_generate_racks(self):
        # Racks (recognized by specs) are fetched from the DB.
        # Plates (recognized by specs) are fetched from the DB.
        # Reservoirs are generated.
        self.add_debug('Fetch or generate racks ...')
        for rack_container in self.parser.rack_containers.values():
            data_item = self.__create_rack_or_reservoir_data(rack_container)
            if data_item is None:
                break
            self.__ror_map[data_item.identifier] = data_item

    def __create_rack_or_reservoir_data(self, rack_container):
        # Determines whether the specified items is a rack or a reservoirs.
        # Fetches racks for which there are barcodes or generates racks
        # without barcode.
        if rack_container.specs is None:
            rack = self.__get_rack_for_barcode(rack_container.barcode)
            if rack is None:
                return None
            else:
                rs = self.__get_reservoir_specs_for_rack(rack)
                if rs is None:
                    return None
                data_item = \
                    RackOrReservoirItem(is_rack=True,
                                        reservoir_specs=rs,
                                        identifier=rack_container.rack_label)
                data_item.set_rack(rack)
                return data_item
        else:
            rs = self.__get_reservoir_specs(rack_container)
            if rs is None: return None
            is_rack = RESERVOIR_SPECS_NAMES.is_rack_spec(rs)
            data_item = \
                RackOrReservoirItem(is_rack=is_rack,
                                    reservoir_specs=rs,
                                    identifier=rack_container.rack_label)
            barcode = rack_container.barcode
            if is_rack:
                if barcode is None and not self.allow_rack_creation:
                    msg = 'When printing or executing worklists directly ' \
                          'all used racks must already be stored in the DB ' \
                          'and be specified by barcode. Rack "%s" does not ' \
                          'have a barcode.' % (rack_container.identifier)
                    self.add_error(msg)
                    rack = None
                elif barcode is None:
                    rack = self.__create_plate(rack_container, rs)
                else:
                    rack = self.__get_rack_for_barcode(barcode)
                    rs = self.__get_reservoir_specs_for_rack(rack, rs)
                    if rs is None:
                        return None
                    data_item.reservoir_specs = rs
                if rack is None:
                    return None
                data_item.set_rack(rack)
            else:
                if barcode is None:
                    barcode = data_item.identifier
                data_item.barcode = barcode
            return data_item

    def __get_reservoir_specs(self, rack_container):
        # Also records an error message if the spec has not been found.
        try:
            rs = get_reservoir_spec(rack_container.specs.lower())
        except ValueError as ve:
            msg = 'Error when trying to fetch reservoir specs for rack "%s": ' \
                  '%s' % (rack_container.identifier, ve)
            self.add_error(msg)
            result = None
        else:
            result = rs
        return result

    def __get_rack_for_barcode(self, barcode):
        # Also records error message if the aggregate did not return a rack.
        rack = self.__rack_agg.get_by_slug(barcode)
        if rack is None:
            msg = 'Could not find rack "%s" in the DB!' % (barcode)
            self.add_error(msg)
        return rack

    def __get_reservoir_specs_for_rack(self, rack, reservoir_specs=None):
        # Fetches the reservoir specs for a rack. If there is already a specs
        # in the file, the specs are compared.
        try:
            rs = get_reservoir_specs_from_rack_specs(rack.specs)
        except ValueError as ve:
            msg = 'Error when trying to determine reservoir specs for ' \
                  'rack "%s" (rack specs "%s"): %s' \
                   % (rack.barcode, rack.specs.name, ve)
            self.add_error(msg)
            result = None
        else:
            if reservoir_specs is not None and not rs == reservoir_specs:
                msg = 'You specified a wrong reservoir spec for rack "%s" ' \
                      '("%s" instead of "%s"). Will use spec "%s".' \
                      % (rack.barcode, reservoir_specs.name, rs.name, rs.name)
                self.add_warning(msg)
            result = rs
        return result

    def __create_plate(self, rack_container, reservoir_specs):
        # Creates a new plate incl. label. The plate specs are derived
        # from the reservoir specs.
        # Creating of stock racks is not allowed.
        try:
            plate_specs = get_rack_specs_from_reservoir_specs(reservoir_specs)
        except ValueError as ve:
            msg = 'Error when trying to determine plate specs for rack "%s": ' \
                  '%s.' % (rack_container.identifier, ve)
            self.add_error(msg)
            result = None
        else:
            rack_id = rack_container.identifier
            plate_label = '%s_%s' % (self.parser.worklist_prefix, rack_id)
            if len(plate_label) > MAX_PLATE_LABEL_LENGTH:
                msg = 'The label that has been generated for the new plate ' \
                      '"%s" ("%s") is longer than %i characters (%i ' \
                      'characters). You will not be able to print this ' \
                      'label properly. To circumvent this problem choose ' \
                      'a shorter rack identifier or a shorter worklist ' \
                      'prefix.' \
                       % (rack_id, plate_label, MAX_PLATE_LABEL_LENGTH,
                          len(plate_label))
                self.add_warning(msg)
            result = plate_specs.create_rack(label=plate_label,
                                             status=get_item_status_future())
        return result

    def __create_worklists(self):
        # Creates :class:`PlannedWorklist` objects and adds them to the
        # :attr:`__worklist_series`
        self.add_debug('Create worklists ...')
        for step_number in sorted(self.parser.step_containers.keys()):
            step_container = self.parser.step_containers[step_number]
            if not self.__has_consistent_rack_shapes(step_container):
                break
            transfer_type = self.__get_transfer_type(step_container)
            if transfer_type is None:
                break
            if not self.__has_only_racks_as_target(step_container):
                break
            planned_liquid_transfers = self.__get_planned_liquid_transfers(
                                                step_container, transfer_type)
            if planned_liquid_transfers is None:
                break
            robot_specs = self.__get_robot_specs(step_container)
            wl_label = '%s_%i' % (self.parser.worklist_prefix, step_number)
            worklist = PlannedWorklist(label=wl_label,
                            transfer_type=transfer_type,
                            planned_liquid_transfers=planned_liquid_transfers,
                            pipetting_specs=robot_specs)
            self.__worklist_series.add_worklist(step_number, worklist)
            for role, rack_ids in step_container.rack_containers.iteritems():
                for rack_id in rack_ids:
                    data_item = self.__ror_map[rack_id]
                    data_item.add_worklist(role, worklist)

    def __has_consistent_rack_shapes(self, step_container):
        # Makes sure the rack items assigned to the source and target layouts
        # of a step have the requested rack shape.
        for role, layout_container in step_container.layouts.iteritems():
            rack_shape = self._convert_to_rack_shape(layout_container.shape)
            if rack_shape is None:
                return False
            for rack_id in step_container.rack_containers[role]:
                data_item = self.__ror_map[rack_id]
                if not data_item.rack_shape == rack_shape:
                    msg = 'The rack shape for layout at %s (%s) does not ' \
                          'match the rack shape for rack "%s" (%s).' \
                           % (layout_container.get_starting_cell_name(),
                              layout_container.shape.name,
                              data_item.identifier, data_item.rack_shape.name)
                    self.add_error(msg)
                    return False
        return True

    def __get_transfer_type(self, step_container):
        # Possible types are SAMPLE_DILUTION and SAMPLE_TRANSFER.
        is_dilution = False
        for rack_id in step_container.rack_containers[TRANSFER_ROLES.SOURCE]:
            data_item = self.__ror_map[rack_id]
            if not data_item.is_rack:
                is_dilution = True
            elif is_dilution:
                # this should not happen because reservoirs have other rack
                # shapes (consistency has already been tested at this point).
                # However, there might be other reservoirs in the future.
                msg = 'The source types for step %i are inconsistent. There ' \
                      'must be either all racks or all reservoirs!' \
                       % (step_container.number)
                self.add_error(msg)
                return None
        if is_dilution:
            transfer_type = TRANSFER_TYPES.SAMPLE_DILUTION
        else:
            transfer_type = TRANSFER_TYPES.SAMPLE_TRANSFER
        return transfer_type

    def __has_only_racks_as_target(self, step_container):
        # Reservoirs must not be targets.
        result = True
        for rack_id in step_container.rack_containers[TRANSFER_ROLES.TARGET]:
            data_item = self.__ror_map[rack_id]
            if not data_item.is_rack:
                msg = 'The target for step %i is a reservoirs. Reservoirs ' \
                      'may only serve as sources!' % (step_container.number)
                self.add_error(msg)
                result = False
                break
        return result

    def __get_robot_specs(self, step_container):
        # Always returns a Biomek spec. If the source racks are tube racks
        # the stock settings are returned.
        result = get_pipetting_specs_biomek()
        for rack_id in step_container.rack_containers[TRANSFER_ROLES.SOURCE]:
            data_item = self.__ror_map[rack_id]
            if isinstance(data_item.rack, TubeRack):
                result = get_pipetting_specs_biomek_stock()
                break
        return result

    def __get_planned_liquid_transfers(self, step_container, transfer_type):
        # Create :class:`PlannedSampleDilution`s for dilution (requires
        # valid diluent), otherwise it creates
        # :class:`PlannedSampleTransfer`s.
        planned_liquid_transfers = []
        for transfer_container in step_container.get_transfer_containers():
            src_positions = transfer_container.get_source_positions()
            trg_positions = transfer_container.get_target_positions()
            volume = float(transfer_container.volume) / VOLUME_CONVERSION_FACTOR
            if transfer_type == TRANSFER_TYPES.SAMPLE_DILUTION:
                diluent = transfer_container.diluent
                if diluent is None or not len(str(diluent)) > 1:
                    msg = 'A diluent must be at least 2 characters long! ' \
                          'Change the diluent for step %i code %s, ' \
                          'please.' \
                          % (step_container.number, transfer_container.code)
                    self.add_error(msg)
                    return None
            for trg_pos_container in trg_positions:
                trg_pos = self._convert_to_rack_position(trg_pos_container)
                kw = dict(target_position=trg_pos, volume=volume)
                if transfer_type == TRANSFER_TYPES.SAMPLE_DILUTION:
                    kw['diluent_info'] = str(transfer_container.diluent)
                    psd = PlannedSampleDilution.get_entity(**kw)
                    planned_liquid_transfers.append(psd)
                else:
                    for src_pos_container in src_positions:
                        src_pos = self._convert_to_rack_position(
                                                            src_pos_container)
                        kw['source_position'] = src_pos
                        pst = PlannedSampleTransfer.get_entity(**kw)
                        planned_liquid_transfers.append(pst)
        return planned_liquid_transfers


class RackOrReservoirItem(object):
    """
    Helper class storing all data required to run worklist tool using the
    rack or reservoir presented here.
    """
    def __init__(self, is_rack, reservoir_specs, identifier):
        """
        Constructor.

        :param bool is_rack: Flag indicating if the object represents a rack
            or a reservoir.
        :param reservoir_specs: contains rack shape, maximum and dead volumes
            for the object (it easier to use unified specs)
        :type reservoir_specs:
            :class:`thelma.entities.liquidtransfer.ReservoirSpecs`
        :param str identifier: The identifier used in the excel sheet.
        """
        #: Does the object represent a rack (*True*) or a reservoir (*False*)?
        self.is_rack = is_rack
        #: contains rack shape, maximum and dead volumes for the object
        #: (it easier to use unified specs)
        self.reservoir_specs = reservoir_specs
        #: The identifier used in the excel sheet.
        self.identifier = identifier
        #: The barcode (if there is one specified).
        self.barcode = None
        #: The :class:`thelma.entities.rack.Rack` entity (if :attr:`is_rack`
        #; is *True*).
        self.rack = None
        #: List of :class:`PlannedWorklist`s for which this item is a source
        #: or target (mapped onto roles).
        self.__worklists = dict()

    def __eq__(self, other):
        return isinstance(other, self.__class__) and \
                 self.barcode == other.barcode

    @property
    def rack_shape(self):
        """
        The rack shape for this rack or reservoir.
        """
        return self.reservoir_specs.rack_shape

    def set_rack(self, rack):
        """
        Sets a rack and a barcode.
        """
        self.rack = rack
        self.barcode = rack.barcode

    def add_worklist(self, role, worklist):
        """
        Registers a worklist in which this object takes over the specified
        role.

        :param role: source or target
            (see :class:`thelma.tools.worklists.TRANSFER_ROLES`)
        :type role: :class:`str`
        :param worklist: a worklist in which this rack or reservoir occurs
        :type worklist: :class:`thelma.entities.liquidtransfer.PlannedWorklist`
        """
        add_list_map_element(self.__worklists, role, worklist)

    def get_worklists_for_source(self):
        """
        Returns the :class:`PlannedWorklist`s for which this items is
        scheduled as source (or an empty list if there are no such worklists).
        """
        return self.__get_worklists_for_role(TRANSFER_ROLES.SOURCE)

    def get_worklists_for_target(self):
        """
        Returns the :class:`PlannedWorklist`s for which this items is
        scheduled as target (or an empty list if there are no such worklists).
        """
        return self.__get_worklists_for_role(TRANSFER_ROLES.TARGET)

    def __get_worklists_for_role(self, role):
        # Helper method return a list of worklists in which this items plays
        # the specified role.
        if not self.__worklists.has_key(role):
            result = []
        else:
            result = self.__worklists[role]
        return result

    def __cmp__(self, other):
        return cmp(self.identifier, other.identifier)

    def __str__(self):
        if self.is_rack:
            return 'Rack %s' % (self.identifier)
        else:
            return 'Reservoir %s' % (self.identifier)

    def __repr__(self):
        str_format = '<%s is rack: %s, ID: %s, reservoir spec: %s>'
        params = (self.__class__.__name__, self.is_rack, self.identifier,
                  self.reservoir_specs)
        return str_format % params

